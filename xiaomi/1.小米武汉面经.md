# ReentrantLock的可重入是怎么实现的
  在源码中提供了公平锁和非公平锁两个版本的可重入获取锁的代码实现,区别也不大,核心区别还是是否要关注等待队列的问题;
  我们这里先介绍非公平锁的底层实现原理
    首先获取当前线程,获取当前state的值;
      如果是0表示当前没有线程正在持有锁,将state设置为传入的acquire(其实就是1),返回true,表示获取锁成功;
      如果不是0,就继续判断,当前线程是否就是持有锁的线程
        如果不是返回false,获取锁失败;
        如果是的话,设置一个int值nextc来接收state+acquire的值
          如果<0,,说明超出int类型的最大取值范围了,抛出错误 Maximum lock count exceeded
          如果正常,修改state值为nextc,返回true,表示成功;
  
  而公平锁相较于非公平锁唯一的区别是:如果state=0时,不会立刻设置当前线程持有锁,而是会检查队列中是否有其他节点,并且这里在检查节点是也考虑到了重入锁的可能性
    Node t = tail; Node h = head; Node s;
    return h != t && ((s = h.next == null) || s.thread != Thread.currentThread());
    先判断头结点不等于尾结点,说明队列中没有其他节点,在将头结点赋给s,进行判断若s为null说明没有其他节点,若s不为null再次判断s.thread和当前线程是否一致,
    若一致就说明是重入锁的情况,需要返回false,若不一致说明有其他线程在等待锁,那么根据公平锁的规则,应优先由队列中等待的线程获取锁,所以返回false;
  
# 怎么理解http无状态协议？
  HTTP是一种用于传输超文本数据的应用层协议,它是构建在TCP/IP协议之上的;Http是一种无状态协议,Http的无状态特性有以下几个方面:
  - 不保留状态信息: 服务器不会保存关于客户端请求的任何状态信息,即使是来自同一个客户端的多个请求也会被视为独立的请求
  - 无连接: Http协议是一种无连接协议,每次请求都需要客户端和服务器建立一个新的连接,请求结束后连接立即关闭,这也就意味着服务器不能区分多个请求是否来自同一个客户端;
  - 简单性: Http无状态的设计使得它非常简单和灵活,服务器不需要为每个客户端维护状态信息,从而减少了服务器的负担,同时也降低了通信的复杂性;
　
# linux查看所有线程命令
  - top -H 
  top本身是查看所有进程信息的命令,而top -H用于查看所有线程,若不支持top -H,可以在输完top命令后,通过按H切换;
  top也可以通过 top -H-p[进程ID] 的方式查看该进程的所有线程;    
　
  - ps -elf
  ps 是用于显示进程状态的命令,通常用于查看系统中正在运行的进程
  -e 表示显示系统中所有进程,而不仅仅是当前用户进程
  -l 表示显示每个进程的线程信息
  -f 表示以完整格式输出
  此外,还可以通过 ps -elf | grep [进程名] 的方式查看指定进程的所有线程
　
# 怎么诊断jvm？
https://www.bilibili.com/video/BV1Dz4y1A7FB?p=61&vd_source=9731d7f588f79e5106b6a98003270b55 
调优监控的依据
    运行日志 异常堆栈 GC日志 线程快照 堆转储快照