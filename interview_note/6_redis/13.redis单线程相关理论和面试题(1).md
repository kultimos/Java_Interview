# 首节高级课程,之后会有对于redis单线程、多路复用、为什么redis速度极快等问题的深度讲解,本节课先入门

# 面试题
  - redis到底是单线程还是多线程
  - IO多路复用听说过吗
  - redis为什么这么快

# redis是单线程还是多线程?
  这种问法其实不严谨,redis的版本很多3.x、4.x、6.x,版本不同架构也是不同的,不限定版本问是否单线程也不太严谨;redis4之后才慢慢支持多线程,知道redis6/7后才稳定;
  3.x版本,最早版本,也就是大家口口相传的redis是单线程,这是对的;
  4.x版本,严格意义来说已经不是单线程了,而是负责处理客户端请求的线程是单线程,但是开始加了点多线程的内容(aof的bgrewriteaof,rdb的写入,像手动触发rdb的bgsave命令在4.x版本也可以使用了)
  6.x版本、7.x版本后,告别了大家印象中的单线程,用一种全新的多线程来解决问题(网络IO线程+主线程),需要注意的是多线程主要指的是用于处理网络IO的线程,真正的命令执行依然是由主线程串行执行的,
也因此在多线程下操作redis也不会出现线程安全问题;
  
# 如何理解redis的单线程
  之所以说redis单线程主要指的是redis的网络IO和键值对读写是由一个线程来完成的,redis采用Reactor模式的网络模型,对于一个客户端请求,主线程负责一个完整的处理过程,即在处理客户端的请求时包括
获取(socket读)、解析、执行、内容返回(socket写),一系列操作都由一个顺序串行的主线程处理,这就是所谓的单线程;
  但redis的其他功能,比如持久化RDB、AOF、异步删除、集群数据同步等等,其实是由额外的线程执行的;(异步删除指的是:在数据删除操作时,redis不会立即释放内存或写入持久化存储,而是将删除操作放入一个
队列中,然后由一个线程异步地执行实际的删除操作,这样可以避免删除操作对主线程的阻塞,提高了redis的性能和响应速度)
  redis命令的工作线程是单线程,但是对于整个redis来说,是多线程的;
  
# 即使是redis3.x的单线程时代,性能依旧很快的原因
  - 基于内存操作: redis的所有数据都存在内存中,因此所有的运算都是内存级别的,所以它的性能比较高;
  - 数据结构简单: redis的数据结构是专门设计的,而这些简单的数据结构查找和操作的大部分时间复杂度都是O(1),因此性能比较高;
  - 多路复用和非阻塞IO: redis使用I/O多路复用功能来监听多个socket连接客户端,这样就可以使用一个线程连接来处理多个请求,减少线程切换带来的开销,同时也避免了I/O阻塞操作;[这是最重要的一点]
  - 避免上下文切换: 因为是单线程模型,因此就避免了不必要的上下文切换和多线程竞争,省去了多线程切换带来的时间和性能上的消耗,而且单线程不会导致死锁问题的发生;

# redis4.0之前一直采用单线程的原因主要有以下几点
  - 使用单线程模型使redis的开发和维护更简单,因为单线程模型方便开发和调试
  - 即使使用单线程模型也可以并发处理多客户端的请求,主要是通过IO多路复用和非阻塞IO
  - 对于redis系统来说,主要的性能瓶颈是内存或者网络宽带而非CPU[官方阐述]
