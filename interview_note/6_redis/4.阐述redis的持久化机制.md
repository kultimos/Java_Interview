# 简述redis的持久化机制
  - RDB: 全称redis database backup file,即redis数据备份文件,也被叫redis数据快照,简单说就是把内存中的所有数据都记录到磁盘中,当redis实例故障重启后,从磁盘读取快照文件,恢复数据

  redis为我们提供了两个可以手动rdb的命令,分别是SAVE和BGSAVE,二者主要的区别在于SAVE命令是阻塞的,执行SAVE命令时,redis服务器将会被阻塞,直到保存整个数据库的操作为止;
  而BGSAVE命令是非阻塞的,执行BGSAVE时会创建一个子进程来执行数据库的保存操作,而父进程可以继续处理其他命令请求;
  默认情况下,redis会在停机时进行一次rdb;
  此外我们可以通过配置一些参数来实现触发rdb的动作:
    我们可以修改redis.conf文件,增加如下的类似参数
    - save 900 1        表示900s内,如果有至少1个key发生了变化,就触发rdb
    - save 300 10       表示300s内,如果有至少10个key发生了变化,就触发rdb
    - save 60 10000     表示60s内,如果有至少10000个key发生了变化,就触发rdb
    - save ""           表示禁用rdb
    需要注意,conf文件允许设置多个save条件来满足不同时间段和数据变化规模下触发rdb的需求
  
  当使用BGSAVE进行rdb时是异步,此时的主线程依然可以对外提供读写服务,那么就存在着数据在rdb过程中被改变的问题,这个问题redis通过copy-on_write来解决,
当主线程需要进行写操作时,会操作一个原始进行rdb数据的数据副本,并且此后的读操作也会去读取这个数据副本,直到rdb结束,这个数据副本会取代原始数据;

  但是RDB仍然存在数据安全性低的问题,RDB是间隔一段时间进行持久化,如果两次RDB之间redis发生故障,就会发生数据丢失;
  
  - AOF: Append Only File 追加文件,redis处理的每一个写命令都会记录在AOF文件,可以看作是命令日志文件

  AOF默认是关闭的,可以通过参数 appendonly yes 来开启AOF
  AOF的命令频率也可以通过redis.conf文件来进行配置
    - appendfsync always      表示每执行一次写命令,立刻记录到AOF文件 | 可靠性高,几乎不丢数据,但是性能差
    - appendfsync everysec    表示写命令执行完后,先放入AOF缓冲区,然后每隔一秒将缓冲区数据写入到AOF文件,是默认方案 | 性能适中,最多也就丢失一秒数据
    - appendfsync no          表示写命令执行完后,先放入AOF缓冲区,然后由操作系统决定何时将缓冲区内容写回磁盘 | 性能最好,但有可能丢失大量数据
  
  AOF因为是记录命令,所以AOF文件会比RDB文件大得多,而且AOF会记录对同一个key的多次写操作,但只有最后一次写操作才有意义;为了解决这个问题,AOF提供了bgrewriteof命令,
通过该命令,可以对现有的aof文件实施重写,生成一个新的AOF文件取代原有的AOF文件,并且这个过程是一个后台异步进行的,即使过程中有新的写操作,命令也会同步记录在新的AOF文件和
旧的AOF文件中,数据不会丢失;
  除了手动触发bgrewriteof命令外,我们还可以通过参数去控制什么时候去重写AOF文件
  - auto-aof-rewrite-percentage 100   AOF文件比上次文件增长超过100%则触发重写
  - auto-aof-rewrite-min-size 64mb    AOF文件体积最小达到64mb才会触发重写


# AOF和RDB之间的对比
　
              RDB                                         AOF
持久化方式:    定时对整个内存做快照                        记录每一次写命令
数据完整性:    两次刷盘之间可能丢失数据                     相对完整,取决于写入策略
文件大小:      文件体积小一些                             记录所有命令,文件体积更大
宕机恢复速度:    快                                        慢
适用场景:     可以忍受数分钟的数据丢失,追求更快的启动速度       对数据安全性要求较高