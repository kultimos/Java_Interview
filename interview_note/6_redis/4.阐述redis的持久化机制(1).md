# 简述redis的持久化机制
  - RDB: 全称redis database backup file,即redis数据备份文件,也被叫redis数据快照,简单说就是把内存中的所有数据都记录到磁盘中,当redis实例故障重启后,从磁盘读取快照文件,恢复数据

  redis为我们提供了两个可以手动rdb的命令,分别是SAVE和BGSAVE,二者主要的区别在于SAVE命令是阻塞的,执行SAVE命令时,redis服务器将会被阻塞,直到保存整个数据库的操作为止;
  而BGSAVE命令是非阻塞的,执行BGSAVE时会创建一个子进程来执行数据库的保存操作,而父进程可以继续处理其他命令请求;
  默认情况下,redis会在停机时进行一次rdb,即如果是在redis-server中执行shutdown,也会触发一次rdb;
  此外我们可以通过配置一些参数来实现触发rdb的动作:
    我们可以修改redis.conf文件,增加如下的类似参数(以下的前三个参数实际上也是redis的默认配置,多个会同时生效)
    - save 900 1        表示900s内,如果有至少1个key发生了变化,就触发rdb
    - save 300 10       表示300s内,如果有至少10个key发生了变化,就触发rdb
    - save 60 10000     表示60s内,如果有至少10000个key发生了变化,就触发rdb
    - save ""           表示禁用rdb
    需要注意,conf文件允许设置多个save条件来满足不同时间段和数据变化规模下触发rdb的需求
    经过我的测试,save 60 2,加入14:10首次进行rdb,那么在到14:11之前,无论我新增多少个key,都不会出发rdb,但是一旦到了14:11,只要我在这一分钟内
  增加了两个key,就会触发rdb;若此后3分钟内都没有新增key,那么如果在14:14:30这时,我只要新增两个key,便会立刻出发rdb;
    所以rdb的触发其实分两种情况,一种情况是大量数据打入,这种情况并不会每当次数达到阈值就进行rdb,而是要同时考虑时间,只有时间和阈值均满足才会rdb,
  第二种情况就是距离上一次rdb的时间已经远远超过时间阈值,这种情况只要满足了修改次数就会即刻触发rdb;
  [上述的配置是redis6.0.16以下的默认配置,在redis7中,将持久化文件rdb的保存规则发生了改变,尤其是时间记录额度变化]
    在redis7中,对应的配置被设置为(其实只有变动最少的那一档配置被修改了,增加了时间,从900s变为3600s)
    - save 3600 1
    - save 300 100
    - save 60 10000 

  当使用BGSAVE进行rdb时是异步,此时的主线程依然可以对外提供读写服务,那么就存在着数据在rdb过程中被改变的问题,这个问题redis通过copy-on-write来解决,
当主线程需要进行写操作时,会操作一个原始进行rdb数据的数据副本,并且此后的读操作也会去读取这个数据副本,直到rdb结束,这个数据副本会取代原始数据;

  rdb的优化参数
  - save <seconds> <changes> 多少s内多少个key的改变,即触发rdb
  - dbfilename  自定义rdb文件名
  - dir  自定义rdb文件位置
  - stop-writes-on-bgsave-error yes  
      用于配置在执行后台持久化操作时遇到错误的处理方式,默认yes
      当这个选项被设置为yes时,表示如果redis在执行后台持久化操作时发生错误,它将停止对写操作的处理,以避免可能导致数据丢失或不一致的情况,通过这个选项可以
    在持久化操作失败时保护数据的完整性,并及时进行故障排查和修复;
      如果这个选项被设置为no时,则redis在后台持久化操作发生错误时会继续处理写操作,可能会导致数据的不一致性;
  - rdbcompression yes
      默认yes,对于存储到磁盘中的快照,可以设置是否进行压缩存储,如果是的话,redis会采用LZF算法进行压缩,如果你不想消耗CPU来进行压缩的话,可以设置为关闭此功能;
  - rdbchecksum yes
      默认yes,在存储快照后,还可以让redis使用CRC64算法进行数据校验,但是这样做会增加大约10%的性能消耗,如果希望获取到最大的性能提升,可以关闭此功能;

  总结rdb
  - 触发RDB的快照的情况
    - 满足了配置文件中默认的快照配置,例如: save 3600 1 
    - 手动执行bgsave和save
    - 执行flushall/flushdb命令也会产生rdb,但是是空的
    - 默认情况执行shoudown,即redis停机时也会执行一次rdb,但如果已经开启了aof持久化的话,停机便不会执行rdb ; 这个结论需要自己试一下,网上没有好的解读
    - 主从复制时,主节点会自动触发一次rdb
 
  - RDB的优点在于:
    - 适合大规模的数据恢复
    - 按照业务定时备份
    - RDB文件在内存中的加载速度要比AOF快得多,所以宕机恢复速度也要更快些;
  但是RDB仍然存在数据安全性低的问题,因为RDB是间隔一段时间进行持久化,如果两次RDB之间redis发生故障,就会发生数据丢失,这个也是RDB最核心的问题
此外,RDB依赖于主进程的fork,在更大的数据集情况下,这可能会导致服务请求的延迟,并且因为fork时内存中的数据被克隆了一份,大致两倍的膨胀性,也需要考虑;
  
  - AOF: Append Only File 追加文件,redis处理的每一个写命令都会记录在AOF文件,可以看作是命令日志文件

  AOF默认是关闭的,可以通过参数 appendonly yes 来开启AOF
  AOF的命令频率也可以通过redis.conf文件来进行配置
    - appendfsync always      表示每执行一次写命令,立刻记录到AOF文件 | 可靠性高,几乎不丢数据,但是性能差
    - appendfsync everysec    [默认方案]表示写命令执行完后,先放入AOF缓冲区,然后每隔一秒将缓冲区数据写入到AOF文件 | 性能适中,最多也就丢失一秒数据
    - appendfsync no          表示写命令执行完后,先放入AOF缓冲区,然后由操作系统决定何时将缓冲区内容写回磁盘 | 性能最好,但有可能丢失大量数据
  
  redis7中的新特性————Multi Part AOF,MP-AOF相较于以前的只有一个appendonly.conf文件,现在有base基本文件、incr增量文件和manifest清单文件;
  并且我们还将aof分为三种类型,分别是:
  - base  表示基础aof,使用aof文件进行数据恢复时也是只使用base.aof进行数据恢复,子进程执行bgrewriteaof会更新该aof;
  - incr  表示增量aof,记录更新语句命令,该文件可能存在多个;每次bgrewriteaof都会清空incr.aof,将其中增量命令去重后写入到base中;
  - history    表示历史aof,它由base和incr变化而来,每次AOFRW成功完成时,本次AOFRW之前对应的base和incr都会变为history,history类型的aof会被自动删除
    为了管理这些aof文件,我们引入了一个manifest文件来跟踪、管理这些aof,同时,为了便于aof备份和拷贝,我们将所有aof和manifest文件放入一个单独的文件目录中,目录
  由appenddirname配置;

  AOF因为是记录命令,所以AOF文件会比RDB文件大得多,而且AOF会记录对同一个key的多次写操作,但只有最后一次写操作才有意义;为了解决这个问题,AOF提供了bgrewriteaof命令,
通过该命令,可以对现有的aof文件实施重写,生成一个新的AOF文件取代原有的AOF文件,并且这个过程是一个后台异步进行的,即使过程中有新的写操作,命令也会同步记录在新的AOF文件和
旧的AOF文件中,数据不会丢失;
  而在redis7以后,bgwriteaof会将incr文件中的内容同步更新到base中,同时清空incr文件;这个的实际效果是原本的数据文件是base1,incr1和manifest文件,那
当我们出发了bgrewriteaof后,实际上会生成base2,incr2,incr2是一个空文件,而base2则是根据base1的内容和incr1的内容进行整合去重得到的新的base文件,并且
原来的base1和incr2会被删除,所以从整体上看认为incr被清空,base被更新,也没什么问题;

  除了手动触发bgrewriteof命令外,我们还可以通过参数去控制什么时候去重写AOF文件
  - auto-aof-rewrite-percentage 100   AOF文件比上次文件增长超过100%则触发重写
  - auto-aof-rewrite-min-size 64mb    AOF文件体积最小达到64mb才会触发重写
  注意: 必须两个条件同时触发,即aof文件比上次增长超过100%,并且aof文件体积已经达到64mb时,才会触发重写;
 
  aof重写原理:
  - redis创建一个"重写子进程",该子进程会读取现有aof,将其包含的指令进行分析压缩并写入到一个临时文件中
  - 与此同时,主进程会继续对外提供服务,如果有新的写指令进来,会一边将写指令放入内存缓冲区,一边继续写入到原有的aof文件,这样就可以保证在
  aof重写过程中的数据一致性
  - 重写子进程完成重写工作后,会将临时文件中的内容添加到新aof文件中,会给父进程发一个信号,父进程接收到信号后就会将内存中缓存的写指令追加到新AOF文件中;
  - 当追加结束后,redis会使用新aof替代旧aof,之后再有新的写指令,就都会追加到新的aof文件中

# RDB+AOF混合持久化
  - 在混合模式下,即同时开启rdb和aof持久化时,重启时只会加载aof文件,不会加载rdb文件;
    - 使用混合方式持久化可以提高数据的可用性和完整性,通过同时使用两种持久化方式,混合模式结合了aof的数据冗余能力以及RDB的快速加载特性,
    从而在某种程度上平衡了性能和安全性的需求;具体来说,当使用混合模式时,redis会先通过aof文件来重建数据,而如果aof文件损坏或有问题时,
    可以通过快速加载RDB文件来迅速恢复数据,这种灵活的机制可以有效的提高数据的完整性和可用性;
      虽然混合模式并不能提高性能,但是可以在一定程度上缓解aof和rdb单独使用时的不足,同时最大限度地发挥两者的优势,从而提高数据的安全性
    和可靠性;综合来看,混合模式在一定程度上能够提高整体系统的稳定性和健壮性;

# 纯缓存模式————同时关掉rdb和aof
  通过配置进行关闭
  - save "", 禁用rdb
  - appendonly on, 禁用aof
  需要注意,即使在禁用持久化模式下,我们仍然可以使用命令save、bgsave生成rdb文件,也可以使用bgrewriteaof生成aof文件

# AOF和RDB之间的对比
　
              RDB                                         AOF
持久化方式:    定时对整个内存做快照                        记录每一次写命令
数据完整性:    两次刷盘之间可能丢失数据                     相对完整,取决于写入策略
文件大小:      文件体积小一些                             记录所有命令,文件体积更大
宕机恢复速度:    快                                        慢
适用场景:     可以忍受数分钟的数据丢失,追求更快的启动速度       对数据安全性要求较高