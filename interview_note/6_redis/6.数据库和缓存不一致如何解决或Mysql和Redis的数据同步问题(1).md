# 数据库和缓存不一致如何解决或Mysql和Redis的数据同步问题
  先说业务场景,其实也就是业务对于一致性的要求高低来选择合理的数据同步方式;
  - 如果对于数据的实时同步要求没有那么高(会出现短期的数据不一致),我们可以采取异步的方案,通过mq消息同步或者是Canal组件监控Mysql的binary log日志把更新后的数据同步redis来实现数据一致性,
    数据的最终一致性；
  - 那如果对数据的一致性要求非常高,就可以考虑redission提供的读写锁来保证数据同步,这个读写锁的特点是: 读锁readLock,锁之后,其他线程可以共享读操作;排他锁writeLock,加锁之后,阻塞其他线程读写,
    这个可以保证数据的强一致性,但是性能就会降低

  此外针对数据库和缓存的问题,我们还提出了以下几种方式(需清晰,均是在高并发下多线程访问时出现的情况)
  并且在陈述回答时,不要过分强调操作失败导致的数据不一致问题,而是将侧重点放在因多线程并发访问造成的数据不一致问题;
  - 先写缓存,再写数据库
      这种情况的异常甚至不需要多线程情况,简单说先写缓存,ok,如果后续写数据库的操作出现一些意外情况导致写入失败,不但现在数据库和缓存数据不一致,而且后续的读操作都会优先读取缓存中的新数据,也就是脏数据,
      我们要清楚,redis的存在是为了查取数据库的数据更快,一切以数据库为主,所以这种方式是完全不考虑的;并且如果高并发情况下,还有这样的问题:请求a和请求b是两个写请求,a先写缓存,b后写缓存,但是a写数据库时
      出现了卡顿,导致b写数据库的动作先一步完成,那待a卡顿结束,a再完成写数据库,就会出现缓存里是b,数据库里确实a,数据不一致的情况
  - 先写数据库,再写缓存
      这种情况也不可取,因为写数据库和写缓存通常是两个事务,而如果写缓存的时候如果出现异常情况导致失败,那么缓存中始终存着旧数据,用户来读数据读的也是旧数据,所以这种方式也一样不考虑
      此外在高并发情况下,还会有这样的问题:请求a和请求b是两个写请求,a先b后,而a在写数据库结束后出现卡顿,利用卡顿的时间,b也完成了数据库的写入,然后b去写缓存,当b写缓存结束后,a的卡顿也结束了,a继续写缓存;
    ok问题出现了,现在数据库里存的是b的新值,但是redis里存的是a的旧值,数据不一致了;
  - 先删缓存,再写数据库(引申出延迟双删)
      加入我们现在有线程a和线程b,a来写,b来读,a先删缓存,然后出现卡顿,此时b进来了,b读redis发现没数据,则先查数据库再将数据写入redis,此时a卡顿结束写数据库,ok,现在数据库是新值,而redis是旧值了,数据不一致;
      也是在这个问题的基础上,提出了延迟双删的理论,即那我们再a写数据库完成后再删除一次redis,是不是就皆大欢喜了？ 也不是,因为有一个很关键的点在于,a在更新数据库后的缓存删除动作必须要在线程b把数据库旧值写入
    缓存之前,否则就是删了个寂寞,旧值依然会被写入redis;所以并不是写完数据库就去删,而是延迟删除,可是延迟多久呢,这也是一个问题,但不得不承认这样做确实可以保证数据库和redis的一致性
      延迟双删的延迟时间如何判断?
      - 首先延迟的时间一定要大于线程b读取数据并写回redis的时间,这个时间如何确定呢?1.通过业务测试,统计线程读写数据的耗时,以此为基础进行进一步的估算,并且要保证写数据的休眠时间比读数据的时间多百毫秒即可,这是
      为了保证写休眠的时间里,足够一个读请求读mysql数据,写回redis一整个动作完毕;2.在启动一个线程,监控主线程,待主线程的写数据库操作完毕后,异步线程再手动去清除一次缓存,来保证下一次读请求的数据一定是数据库中
      数据,但这种方式的实现需要结合后续看门狗机制的源码分析来实现[待补充],此外,用一个监听器来实现这个过程应该也是可以的,明天试一下;
  - 先更新数据库,再删缓存
      这种情况是比较好的,只有在空隙时间内可能出现线程读取旧值的问题,比如线程a和线程b,a写b读,a刚刚把数据写入mysql,还没来得及删,b就来读了,那么此时b读到的数据是redis中应被删除而未被删除的旧值,也是只有
    这一种情况下会出现数据不一致的问题,但我觉得这也不算严格意义上的数据不一致,这相当于是极小空隙下的数据不一致,而不是上述的操作会造成长时间数据不一致的情况,所以这种方案也是目前使用最多的方案;
    同样是多线程的场景,a先b后,a更新数据库,还没更新完,b来了b去更新数据库,b先更新了,然后b去删缓存,那么如果这个时候来请求,无论a写数据库的动作完成与否,此时缓存都是空的,那么对于这次请求来说,缓存和数据库的值即使不是最新的,却
    也不会不一致,双写一致性的核心问题在于保证数据更新时数据库和缓存的数据一致性,所以这种先更新数据库再删缓存的方案是最好的;
      也会存在两个线程,a写b写,最终a写完,b去写,还没来得及删redis中a的记录,请求就进来了,这时候会有短暂的数据不一致性,所以该方案也是无法做到100%的双写一致性的;

  [redis和mysql的双写100%会出纰漏,做不到强一致性,你如何保证最终一致性]
  引入中间件;
  1)可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中
  2)当程序没有能够正常地删除缓存值或者是更新数据库值时,可以从消息队列中重新读取这些值,然后再次进行删除或更新
  3)如果能够成功地删除或更新,我们就要把这些值从消息队列中去除,以免重复操作,此时,我们也可以保证数据库和缓存的数据一致了,否则还需要再次进行重试
  4)如果重试超过一定次数后还是没有成功,就需要向业务层发送报错信息了;   
  通过canal,伪装成一个从机,不断监听主mysql的数据变化,并在java服务端程序中,将这些数据同步到Redis中,如果担心同步的过程中出现写redis异常的问题,还可以考虑把数据发送至kafka,只有成功写redis,才ack;