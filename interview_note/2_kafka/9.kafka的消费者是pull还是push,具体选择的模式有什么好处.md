# kafka的消费者是pull还是push,具体选择的模式有什么好处    这个我觉得网上就没有一个讲的非常清楚的
  kafka选择的是由consumer从broker中pull拉取消息
  由broker决定消息推送的速率,对于不同消费速率的consumer就不太好处理了;消息系统都致力于让consumer以最大的速率最快速的消费消息,但不幸的是,push模式下,
当broker推送的速率远大于consumer消费的速率时,consumer恐怕就要崩溃了;
  Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据,而Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送;
如果为了避免consumer崩溃而采用较低的推送速率,将可能导致一次只推送较少的消息而造成浪费;而Pull模式下,consumer就可以根据自己的消费能力去决定这些策略; 
  Pull有个缺点是,如果broker没有可供消费的消息,将导致consumer不断在循环中轮询,直到新消息到t,为了避免这点,kafka也提供来了配置参数来进行优化
  - fetch.min.bytes: 该参数指定了Broker在响应消费者拉取请求之前等待收集到足够的数据的最小字节数
  - fetch.max.wait.ms: 该参数指定了消费者在向Broker发送拉取请求后,等待数据的最长时间
    如果Broker收到的数据量达到,或超过了fetch.min.bytes,则会立即将数据发送给消费者
    如果Broker收到的数据量未达到fetch.min.bytes,则会开始等待,直到数据量达到或超过fetch.min.bytes或者等待时间超过fetch.max.wait.ms,而一旦等待超时,consumer也就不会在继续轮询下去了;

  Kafka的消费者默认是采用拉(pull)模式来获取消息,即消费者定期轮询(pull)来检查是否有新的消息可供消费,这是因为拉模式在大多数情况下更为灵活和可控,特别是在处理大量数据或需要严格控制处理速度时;
  然而,Kafka也提供了监听器(listener)或回调(callback)机制,允许消费者注册回调函数来异步处理消息,这种机制在消息到达时可以被视为一种推(push)模式,因为 Kafka 会主动通知消费者,而不需要消费者
不断轮询;尽管这些回调函数提供了一种类似于推模式的机制,但实际上它们仍然基于拉模式,因为消费者在轮询期间会检查是否有新的消息,并在有新消息时调用注册的回调函数进行处理;因此,这种机制并不会完全改变
Kafka消费者的工作方式,而只是提供了一种更为灵活的消息处理方式;