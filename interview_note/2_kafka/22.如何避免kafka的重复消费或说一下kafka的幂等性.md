# 如何避免kafka的重复消费或说一下kafka的幂等性
  kafka的幂等性意味着无论一个消息被发送多少次,它都只会被接收和处理一次,保证消息的一次性投递;这个特性主要是为了防止在消息传输过程中因为网络或
其他问题导致的消息重复,确保数据的准确性和一致性;
  在kafka中,幂等性主要是通过内部机制实现的,涉及到生产者、broker和topic配置的相互作用;启用幂等性的生产者确保了单个分区内的消息是幂等的,也就是说,
即使生产者尝试多次发送同一个消息,该消息在消费者那里也只会被处理一次;
  幂等性在kafka中的实现主要依赖于以下两个关键点:
  - 生产者ID和序列号: 当幂等性被启用时,Kafka给每个新的生产者分配一个唯一一个ID(pid);每条消息都被生产者附加一个序列号,kafka利用这个ID和序列号
                   来识别和去除重复的消息;如果kafka收到了两个具有相同pid和序列号的消息,它只会处理第一个,后续的消息将被忽略; 
  幂等性是kafka生产者为了避免因为生产者重试而造成的消息重复写入的问题,但是消息的重复消费不止这一种原因,生产者方面的问题处理完以后,该处理消费者这一侧的问题;

# 消费者重复消费的场景
  kafka默认消费位移的提交是自动提交,由消费者参数enable.auto.commit配置,默认为true
  这个自动提交并不是每消费一条消息就自动提交消费位移,而是定期提交,这个定期提交的时间由客户端参数auto.commit.interval.ms配置,默认5秒,也就是说,在默认情况下,
消费者每隔5秒会将拉取到的每个分区中最大的消息位移进行提交
  注意:自动提交的动作在poll()方法的逻辑中,在每次向服务器端发起拉取请求之前会检查是否可以进行位移提交,如果可以就提交上一次轮询的位移;
  那么可以发现,在拉取消息进行消费之前时,未提交消息最大位移的消费者如果崩溃,那么这段消息的消费就丢失了,下一次还需要从上一次消费的最初位置重新开始消费,这种情况就会造成重复消费;
  对于这种场景我们的解决办法是: 设置手动提交消费位移;
  
  也可以在业务端通过唯一标识存入redis来保证不会重复消费;