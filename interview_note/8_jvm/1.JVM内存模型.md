# JVM内存模型
  - 虚拟机栈(线程栈)
    只要有线程开始运行,虚拟机栈就会为这个线程开辟出一块虚拟机栈自有的内存,存放该线程的局部变量,如果存放的是对象信息就是对象在堆中的内存地址
    虚拟机栈中的重要概念————栈帧,一个线程在执行过程中可能会调用多个方法,每调用一个方法,就会在这个线程被分配到的内存空间中,拿出一部分来专门记录这个方法的相关变量,
  栈帧是在线程被分配的内存中二次分配的,所有栈帧都在一个线程内存中,栈帧中又由四部分组成
    - 局部变量表: 存放方法中的局部变量
    - 操作数栈: jvm底层在做程序操作时用来存放操作数的内存空间
    - 动态链接: 将调用方法的符号引用转换为直接引用的过程是静态链接;而被调用的目标方法在编译器无法确定下来,只能够在程序运行期将方法的符号引用转换为直接引用的过程就是动态链接;
    - 方法出口: 执行完该段代码后,下一行要运行的代码,存放的是调用者的程序计数器地址;

  - 方法区(元空间)
    jdk1.8之前方法区通常被称为永久代,而在jdk1.8之后,永久代被移除,取而代之的是元空间;    
    包含常量、静态变量、类信息,运行时常量池

  - 程序计数器
    程序计数器记录的是java虚拟机将要执行的下一行代码的行号,实际也是即将执行的代码的内存地址,之所以设计程序计数器是因为在多线程场景下,可能当前线程执行到一半,cpu资源被抢占,
  进入挂起状态,待重新拿到cpu执行权后,需要依靠程序计数器来获悉代码位置,程序计数器是线程私有的;

  - 本地方法栈
    与虚拟机栈类似,只不过本地方法栈中存放的都是native相关方法

  - 堆
    由新生代和老年代组成,新生代中又分成了两个eden区和一个Survivor区,比例为1:1:8;

  这里面虚拟机栈、本地方法栈和程序计数器都是线程私有的,而方法区和堆是被所有线程共享的内存区域;
  
方法区是逻辑上的概念,用于存储已经加载的类的结构信息、静态变量、常量池、方法字节码等等
它的具体实现:
  - 永久代: 本身也是堆内存的的一部分,是JDK8之前的实现方式,用于存储已经加载的类的结构信息、静态变量、常量池、方法字节码等;
  - 元空间: 是JDK8以后的实现方式,用于存储类元信息;它使用本地内存(有操作系统直接分配和管理的内存),而不是堆内存来存储;元空间的大小可以动态调整;
像静态变量和字符串常量池都是在堆中,而类元信息和运行时常量池都在元空间中;字符串常量存在堆中,编译期常量存储在元空间中

方法区本身也参与垃圾回收,而永久代和元空间在垃圾回收时的实现夜有所区别
  - 永久代: 主要针对常量池的回收和类的卸载,一般只在类加载器的生命周期结束时才会进行类的卸载(不够及时)
  - 元空间: 具有自动的内存管理机制(无需开发者干预),可以更好地管理和回收不再使用的类和元数据(相对更加及时)