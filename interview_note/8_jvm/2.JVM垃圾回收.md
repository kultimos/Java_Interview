# JVM垃圾回收
  垃圾回收关注的区域主要是方法区和堆区;
  
# 死亡对象(可GC对象的判断算法)
  - 引用计数器算法
    给对象增加一个引用计数器,每当有一个地方引用它时,计数器就+1;当引用失效时,计数器就-1,任何时刻计数器为0的对象就是不能再使用的,即死亡对象;但是这个算法存在一个无法解决的对象之间
  循环引用的问题,导致无法回收互相引用的资源,这个问题也导致目前主流JVM都没有使用引用计数法;
  - 可达性分析法
    目前主流的JVM采用的就是可达性分析法,核心思想是:通过一系列"GC ROOTS"的对象作为起始点,从这些节点开始向下搜索,所搜的路径称为"引用链",当一个对象到GC ROOTS没有任何的引用链相连时,
  即从GC ROOTS到这个对象不可达时,证明这个对象是不可用的;
    在java中,可作为GC ROOTS的对象包含下面几种:虚拟机栈引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中Native引用的对象;

# 垃圾回收算法
  - 标记清除法
    最基础的收集算法,分为标记和清除两个阶段: 首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象;它的缺点一方面是效率问题,标记和清除这两个过程效率都不高;此外空间问题,
  标记清除后会产生大量不连续的内存碎片,空间碎片太多可能会导致以后在程序中需要分配较大对象时,无法找到足够大的连续内存而不得不提前触发另一次垃圾回收;
  - 复制算法
    复制算法是为了解决效率问题,它将可用内存按照容量划分为大小相等的两块,每次只使用其中的一块,当这块内存用完了,就将还存活着的对象复制到另一块内存上,然后再把当前使用的这块内存一次清理掉;
  这样的好处就是每次都是对整个半区内存进行回收,为新的大对象分配内存也不需要考虑内存碎片的问题,只需要正常按顺序分配就行,但是这种算法的代价就是可用内存实际上变成了原来的一半;并且该算法的
  效率跟存活对象的数目有很大关系,如果存活对象很多,那么算法的效率将会大大降低。
    现代商用的虚拟机都采用这种算法来回收新生代,堆中的新生代的98%的对象都是“朝生夕死”,所以不需要按照1:1的比例来划分内存,而是将内存分成一块较大的Eden区和两个较小的Survivor区,
  每次使用的是Eden区和其中一块Survivor区;当回收时,将eden区和survivor区中还存活的对象一次性复制到另一块survivor区上,最后清理掉eden区和刚才用过的那个survivor区;
  Hotspot默认Eden区和Survivor区的比例是8:1:1,可知每次新生代的可用内存为整个新生代容量的90%,而剩下的10%用来存放回收后存活的对象;
  - 标记整理法
    复制算法在存活率较高的情况下,效率会降低;并且在复制算法中如果survivor区空间不足时,还需要老年代进行内存分配担保,所以复制算法并不适用于老年代的垃圾回收;
    而标记整理法则比较适合在老年代使用,该算法在标记阶段跟标记清除法一样,先标记出可回收对象,然后会将存活对象向一端移动,最后清理端边界以外的内存
  - 分代收集法
    分代收集法是目前大部分JVM的垃圾收集器采用的算法,它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域;一般情况下将堆区划分为老年代、新生代,老年代的特点是
  每次垃圾回收时只有少量对象需要被回收,而新生代的特点是每次垃圾回收时都有大量的对象需要被回收,那么就可以根据不同代的特点采取最适合的收集算法;
    目前大部分垃圾收集器对于新生代都采取复制算法,因为新生代中,每次垃圾回收都要回收大部分对象,按照8:1:1的比例,每次清理eden和一个survivor区的垃圾,然后将存活对象存入
  另一个survivor;而由于老年代每次都回收少量对象,一般使用的是标记整理法;

# 使用复制算法进行垃圾回收时可能出现的问题:
  - 当使用复制算法进行垃圾回收时,如果出现存活对象的大小已经超过了另一个survivor的区域,该如何处理
    当通过复制算法进行垃圾回收时,如果存活对象的大小已经超过了另一个Survivor区可用空间,这种情况通常会触发一次对象晋升,而不是简单地复制到另一个Survivor区;
    晋升操作是指将存活时间较长的对象从新生代(包括Eden区和Survivor区)移到老年代,这是为了避免在新生代中出现存活时间较长的对象导致频繁复制,从而降低新生代的效率;
    晋升发生在以下情况: 
    - 当对象多次Minor GC仍然存活时,它们会晋级到老年代 
    - 当Survivor区空间不足以容纳存活对象时,即使对象的分代年龄<15,一些分带年龄稍大的存活对象也会被晋升到老年代;
  