# 常见的垃圾回收器

  ## G1垃圾回收器(对内存要求较高)
  - G1把连续的Java堆划分为多个大小相等的独立区域(Region),每个Region都可以根据需要,扮演新生代的Eden空间、Survivor空间或者老年代空间;收集器
  能够对扮演不同角色的Region采用不同的策略去处理;这样就可以更精细的控制(只把eden空间对应的region拿来进行回收,并且可以通过JVM参数设置一次GC回
  收几个region和一次GC的回收时间,同时还有优先级处理即可以优先去回收内存更大的region)
  - G1垃圾回收分为四步
    - 初始标记: 单线程运行,需要STW,标记GC Roots能直达的对象
    - 并发标记: 无停顿,和用户线程同时运行,从GC Roots直达对象开始遍历整个对象图
    - 最终标记: STW,标记并发阶段产生的对象(有些在并发标记中标记的对象可能发生变化)
    - 筛选回收: 制定回收计划,选择多个Region构成回收集,把回收集中的存活对象复制到空的region中,然后清理掉整个旧region,需要STW;

  ## CMS垃圾回收器
  - CMS垃圾回收分为四步
    - 初始标记: 在这个阶段中,程序中所有的工作线程都将会因为stw出现短暂的暂停,这个阶段主要任务仅仅只是标记出GC ROOTS能直接关联到的对象,一旦标记
    完成之后就会恢复之前被暂停的工作线程;由于直接关联对象比较少(GCroots引用链可能很长,但起点并不会很多),所以这里速度很快
    - 并发标记: 从GC ROOTS的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长,但是不需要停顿用户现场,可以与垃圾回收线程并发运行
    - 重新标记: 由于在并发标记阶段中,程序工作线程会和垃圾收集线程并行运行,所以可能出现个别对象在初始标记和并发标记两个时间的可达性发生变化,所以我
    们需要再最终进行删除之间,进行一次重新标记
    - 并发删除: 无停顿,和用户线程同时运行,清理掉标记阶段标记的死亡对象
  - 由于最耗时的并发标记与并发删除阶段都不需要暂停用户现场,所以整体的回收是低停顿的
  - 由于CMS采用的是标记清除法,所以会产生内存碎片

  ## SerialGC,串行垃圾回收器
  - 最基本、历史最悠久的垃圾回收器,jdk1.3之前回收新生代唯一的选择
  - 年轻代采用复制算法,垃圾回收时会STW
  - 在进行垃圾回收时,必须暂停所有的工作线程,直到它收集结束

  ## ParNew,并行单线程垃圾回收器
  - 是Serial收集器的多线程版本
  - 但需要注意,只有在多核cpu的情况下,ParNew才会比Serial的回收效率更高,若在单核cpu的情况下,反而是Serail的回收效率更高,因为其避免了多线程交互
  过程中产生的开销
  - 设计目的是减少单次垃圾回收的停顿时间,从而提供更好的响应时间
  - 主要用于需要低延迟的程序,如交互式应用或web应用

  ## Parallel Scavenge回收器 吞吐量优先
  - 和ParNew收集器不同,Parallel Scavenge收集器的目标是达到一个可控制的吞吐量,所以它也被称为吞吐量优先收集器
  - 它通过并行执行垃圾回收任务来减少垃圾回收的总时间,从而提高应用程序的整体性能
  - 特别适合于长时间运行、对吞吐量要求高的大型应用,如服务端应用