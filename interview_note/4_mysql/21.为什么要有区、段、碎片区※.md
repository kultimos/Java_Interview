2.为什么要有区?
  - B+树的每一层中的页都会形成一个双向链表,如果是以页为单位来分配存储空间的话,双向链表相邻的两个页之间的物理位置可能离得非常远;我们在介绍B+树
  索引的适用场景时特别提到范围查询只需要定位到最左边记录和最右边记录,然后沿着双向链表一直扫描就可以了;而如果链表中相邻的两个页物理位置距离很远,
  实际上就是随机IO了,随机IO是非常慢的,所以我们应尽量让链表中相邻的页的物理位置也相邻,这样进行范围查询的时候才可以使用顺序IO
  引入区的概念,一个区就是在物理位置上连续的64个页,因为InnoDB中的页大小默认是16KB,所以一个区的大小是64*16KB=1MB,在表中数据量大的时候,
  可以为某个索引分配空间的时候就不在按照页为单位分配了,而是按照区为单位分配,甚至在表中数据特别多的时候,可以一次性分配多个连续的区,虽然可能造成
  一点点空间的浪费(数据不足以填满整个区),但是从性能角度来看,可以消除很多随机IO,功大于过;

3.为什么要有段? 
  - 对于范围查询,其实是对B+树叶子节点中的记录进行顺序扫描,而如果不区分叶子节点和非叶子节点,统统把节点代表的页面放到申请到的区中,进行范围查找的
  效率就大打折扣了(我个人的理解:因为范围查找时只需要先找到最大值和最小值,然后遍历就可以;而在查找最大最小值的时候,其实分为两步,先要在非叶子结点里
  找到符合范围的页,而这一步时其实大量的叶子节点就会干扰我们的查找速度)
  所以InnoDB中叶子结点和非叶子结点都有自己独有的区,而[存放叶子结点的区的集合就是一个段,通常我们称之为数据段],而[存放非叶子结点的区的集合也是
  一个段,通常我们称之为索引段];
  - 除了数据段和索引段之外,还有回滚段;段并不对应表空间中某一个连续的物理区域,而是一个逻辑上的概念,由若干的零散的页面(这些零散的页面存放在碎片区中)
  以及一些完整的区组成

4.为什么要有碎片区?
  - 默认情况下,一个使用InnoDB存储引擎的表只有一个聚簇索引,一个索引会生成两个段(数据段,索引段),而段是以区为单位申请存储空间的,一个区默认占用
  1M(64*16kb=1024kb)存储空间,所以默认情况下一个只存了几条记录的小表也需要2M的存储空间吗？这对于存储记录比较少的表来说是巨大的浪费;
  这个问题的症结在于到目前为止我们介绍的区都是非常纯粹的,也就是一个区被整个分配给某一个段,或者说区中的所有页面都是为了存储同一个段的数据而存在,
  即使段的数据填不满区中的所有页面,那余下的页面也不能挪作他用;
  为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况,InnoDB提出了一个碎片区的概念;在一个碎片区中,并不是所有的页
  都是为了存储同一个段的数据而存在的,而是碎片区中的页可以用于不同的目的,比如有得页用于段A,有的页用于段B,有些页甚至哪个段都不属于;
  碎片区直属于表空间,并不属于任何一个段;
  所以此后为某个段分配存储空间的策略是这样的
  - 在刚开始向表中插入数据的时候,段是从某个碎片区以单个页面为单位来分配存储空间的
  - 当某个段已经占用了32个碎片区页面之后,就会申请以完整的区为单位来分配存储空间所以现在段不能仅定义为是某些区的集合,更精确的应该是某些零散的页
  以及一些完整的区的集合