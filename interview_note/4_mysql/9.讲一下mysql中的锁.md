# mysql中的锁
  ## 从数据操作的类型划分: 共享锁和排他锁
  - 读锁也称共享锁、S锁,针对同一份数据,多个事务的读操作可以同时进行而不会互相影响
  - 写锁也称排他锁、X锁,如果当前写操作未完成,会阻断其他的读锁和写锁

  ## 排他锁
  - 排他锁顾名思义是会阻断其他的锁,不但在持有排他锁时会阻断其他锁,在获取某行的排他锁时,如果此时该行正持有共享锁,那么也需要等待其共享锁释放,这是因
  为排他锁要求对数据独占访问权限

  ### 共享锁和排他锁的语法
  - 对读取记录加S锁
    - select * from table LOCK IN SHARE MODE;
    - select * from table FOR SHARE;

  - 对读取记录加X锁
    - select * from table FOR UPDATE;

  - 在mysql8.0之前,获取不到锁会一直等待,直到超时;但在8.0版本中,可以通过添加后缀来跳过锁等待或者跳过锁定
    - select * from table For SHARE NOWAIT; 表示如果查询数据已经加锁,则会立即报错返回
    - select * from table For SHARE SKIP LOCKED; 表示如果查询数据已经加锁,立即返回,返回内容中不包含被锁定的行;

  ## 从锁的粒度上划分: 表级锁、页级锁、行锁
    
  ### 表锁
  - 表级锁有X锁、S锁、自增锁、元数据锁和意向锁,对于表锁来说,自增锁、意向锁是更重要的一种,而X锁、S锁相对来说在行锁的级别中更值得深究

  ### 意向锁
  - 意向锁可以跟行锁共存,当我们给某一行添加一个读锁时,mysql会自动给我们这个表加一个表级意向S锁;如果我们添加的行锁是X锁,那么表上添加的就是表级意
  向X锁;
  - 意向锁也同样具有共享锁和排他锁的特性,但只跟表级锁才会产生冲突,比如表级意向排他锁会和表级意向共享锁或者是表级读锁,都会互斥;

  ### 意向锁要解决的问题
  - 现在有两个事务,分别是T1和T2,其中T2试图在该表级别上应用共享或排它锁,如果没有意向锁存在,那么T2就需要去检查每个页或行是否存在锁,效率很低;如果
  存在意向锁,那么此时就会受到由T1控制的表级别意向锁的阻塞,T2在锁定该表之前就不用检查各个页或行锁,而只需要检查表上的意向锁;
  - 可以说从根本上解决了行级排他锁和表级排他锁冲突的问题
 
  ### 自增锁
  - 自增锁是一个表级别的锁,具象化的体现是我们会在一些表中为主键设置auto increment

  ### 自增锁是如何保证多个事务向表中插入数据时,主键的唯一性的呢
  - 首先要清楚插入数据时的三种插入方式: 简单插入、批量插入和混合模式插入
    - 简单插入: 插入时确定了要插入的行数
    - 批量插入: 插入时不确定要插入的行数
    - 混合插入: 插入时只指定了部分列的值,其他列的值需要依赖于auto increment
  - 自增锁有三种锁定模式
    - 传统锁定模式: 在此模式下,所有类型的insert语句都会获得一个特殊的表级自增锁,多事务执行时并发性差
    - 连续锁定模式: 是Mysql8.0前的默认模式,对于批量插入来说,连续锁定和传统锁定没区别,每一次insert都会加锁;但对于简单插入来说,因为事先知道要
    插入多少条数据,所以获取了自增锁之后就可以得到需要的自增区间,就可以释放自增锁了,这样相当于n条数据只需要获取和释放一次自增锁;
    - 交错锁定模式: 是Mysql8.0后的默认模式,在此模式下,所有类型的插入都不会持有自增锁,并发性很好,但是由于多条语句同时生成数字,所以为任何给定语句
    插入的行生产的值可能不是连续的;

  ### 元数据锁
  - 无需显式使用,Mysql自动加的
  - 当我们进行数据增删改查时,会分配一个DML读锁,如果我们试图改变表结构,会分配一个DML写锁,DML写锁会阻塞其他试图获取DML读锁的事务,这是为了避免在
  一个事务中多次查询发现表结构都不同的尴尬情况

  ## 行锁
  - 行锁: 共享记录锁、排他记录锁、临键锁、间隙锁、插入意向锁
  - 对插入意向锁印象最浅,这里说一下
    - 插入意向锁本质是一种间隙锁,因为他的竞争锁的对象时间隙锁;
    - 插入意向锁在insert操作时产生
    - 当我们试图插入一条记录时,如果发现该位置已经被其他事务添加了临键锁,那我们需要等待,InnoDB规定事务在等待时也需要在内存中生成一个锁结构,这就是
    插入意向锁



















