# first小吴:
第一反应是引用不可变,但是引用的值可以改变的对象,但是很明显不对,这是final对象的概念;

# 结论:
不对的

# 改正后(可背):
  可以,思路很简单;
  外部是一个不可变对象,所以该对象的所有属性都应该不提供set方法,属性的初始化放在构造方法中,这样一来即使包含一个可变对象属性,也没用方式可以去改变;
  但是有一点需要注意,对于包含可变对象的不可变对象,为了避免可变对象内部状态的变化影响到不可变对象本身的不可变性,一般需要在构造函数中进行一次防御性拷贝操作,
从而保证不可变形的有效性,这样说可能有些抽象,看代码 [](/src/main/java/foundation/ImmutableClass.java)