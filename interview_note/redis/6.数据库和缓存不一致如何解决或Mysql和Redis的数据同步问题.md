# 数据库和缓存不一致如何解决或Mysql和Redis的数据同步问题
  先说业务场景,其实也就是业务对于一致性的要求高低来选择合理的数据同步方式;
  - 如果对于数据的实时同步要求没有那么高(会出现短期的数据不一致),我们可以采取异步的方案,通过mq消息同步或者是Canal组件监控Mysql的binary log日志把更新后的数据同步redis来实现数据一致性,
    数据的最终一致性；
  - 那如果对数据的一致性要求非常高,就可以考虑redission提供的读写锁来保证数据同步,这个读写锁的特点是: 读锁readLock,锁之后,其他线程可以共享读操作;排他锁writeLock,加锁之后,阻塞其他线程读写,
    这个可以保证数据的强一致性,但是性能就会降低

  此外针对数据库和缓存的问题,我们还提出了以下几种方式(需清晰,均是在高并发下多线程访问时出现的情况)
  - 先写缓存,再写数据库
      这种情况的异常甚至不需要多线程情况,简单说先写缓存,ok,如果后续写数据库的操作出现一些意外情况导致写入失败,不但现在数据库和缓存数据不一致,而且后续的读操作都会优先读取缓存中的新数据,也就是脏数据,
      我们要清楚,redis的存在是为了查取数据库的数据更快,一切以数据库为主,所以这种方式是完全不考虑的;
  - 先写数据库,再写缓存
      这种情况也不可取,因为写数据库和写缓存通常是两个事务,而如果写缓存的时候如果出现异常情况导致失败,那么缓存中始终存着旧数据,用户来读数据读的也是旧数据,所以这种方式也一样不考虑
      此外在高并发情况下,还会有这样的问题:请求a和请求b是两个写请求,a先b后,而a在写数据库结束后出现卡顿,利用卡顿的时间,b也完成了数据库的写入,然后b去写缓存,当b写缓存结束后,a的卡顿也结束了,a继续写缓存;
    ok问题出现了,现在数据库里存的是b的新值,但是redis里存的是a的旧值,数据不一致了;
  - 先删缓存,再写数据库(引申出延迟双删)
      加入我们现在有线程a和线程b,a来写,b来读,a先删缓存,然后出现卡顿,此时b进来了,b读redis发现没数据,则先查数据库再将数据写入redis,此时a卡顿结束写数据库,ok,现在数据库是新值,而redis是旧值了,数据不一致;
      也是在这个问题的基础上,提出了延迟双删的理论,即那我们再a写数据库完成后再删除一次redis,是不是就皆大欢喜了？ 也不是,因为有一个很关键的点在于,a在更新数据库后的缓存删除动作必须要在线程b把数据库旧值写入
    缓存之前,否则就是删了个寂寞,旧值依然会被写入redis;所以并不是写完数据库就去删,而是延迟删除,可是延迟多久呢,这也是一个问题,但不得不承认这样做确实可以保证数据库和redis的一致性
  - 先更新数据库,再删缓存
      这种情况是比较好的,只有极其特殊的场景才有可能出现数据不一致的问题,那我们下面简单说一下这种极其特殊的场景
      首先就是需要redis中的key恰好到了过期时间,失效了,这种情况下,多并发情况存在读请求先去数据库读旧值,然后写缓存时出现卡顿,而这个时候写请求已经完成了写入数据库的动作,那么等待卡顿结束,此时读请求就会把旧值写入
    缓存,在这种情况下就会出现数据不一致的可能性;所以其实是最推荐先写数据库,再删除缓存的方案;