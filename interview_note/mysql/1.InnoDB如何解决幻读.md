# first小吴:
  读未提交  
  读提交    脏读
  可重复读  可重复读
  序列化    幻读
  
  Innodb中采用了两种方式来解决幻读,首先是通过事务隔离级别,通过序列化的方式来解决多个事务之间的幻读问题,因为是序列化,所以不存在同一时间多个事务操作的情况,也就避免了幻读
的发生,但是这种方式过于简单粗暴,在mysql服务器访问量较大的场景下,就无法通过该手段解决幻读问题;
  第二种是通过MVCC,在MVCC的场景下,为了解决幻读,只会在最开始时ReadView读取一次数据的值

# 结论:
  这里小吴说的内容是有些乱的,而且既没有关注到innodb引擎的情况,具体问题具体分析,又缺少对于幻读现象本身的剖析,可以不用看了,不正确;

# 改正后(可背):
  关于幻读,目前通常有两种解释的方式,第一种是在同一个事务中同一条查询语句的多次查询结果不一致,第二种是在同一个事务中对某id的数据进行查询,发现并没有该id的数据,
但是当我试图新插入一条该id的数据时,innodb又报错,显示该id的数据已存在
  如果这里我们不限定Innodb引擎的话,在多个事务隔离级别的定义中,序列化是用于解决幻读问题的,但序列化无法满足并发的要求,所以在Innodb引擎中,我们在可重复读的隔离
级别下,通过间隙锁和临键锁的方式最终实现了对幻读问题的解决,顺便一提,Innodb中默认的事务隔离级别就是可重复读;
  假设我们现在有四条数据,1,3,7,10;执行语句select * from t where id = 9,那么对于间隙锁来说,(7,10)这个区间已经被锁定,这样就可以有效地防止其他事务新增
数据影响我们当前事务,至于临键锁只是比间隙锁又多了记录锁的能力,即可以同时锁住一条记录和一个范围;
  总结一下就是在InnoDB引擎下,通过可重复读的隔离级别+间隙锁(临键锁)可以解决幻读问题;
  