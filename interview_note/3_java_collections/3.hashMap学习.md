# hashMap学习

  # basic技术点
  hashmap的键和值都是允许为null的
  JDK1.8之前hashmap是数组+链表,entry数组是hashmap的主体,链表则是为了解决哈希冲突
  JDK1.8之后在解决哈希冲突时有了较大的变化,当链表长度大于阈值(默认为8),并且当前数组的长度大于64时,此时该索引位置上的所有数据改为使用红黑树存储;但如果链表长度大于8,
但是数组长度小于64,此时并不会将链表转为红黑树,而是选择进行数组扩容;这么做的目的是因为当数组比较小时,应尽量避开红黑树结构,这种情况下变为红黑树反而会降低效率,因为红黑树
需要进行左旋,右旋,变色这些操作来保持平衡;虽然使用红黑树作为底层的数据结构,明显结构更复杂了,但是阈值大于8并且数组长度大于64时,链表转换为红黑树,实际效率变得更高了,之所以
将这个阈值定为8也是出于空间和时间的权衡;并且如果树的节点个数小于6,也会将红黑树再转回为链表
  hashmap中默认的负载因子是0.75
  hashmap的最大容量是2的30次幂

  # hashmap的特点
  - 存取无序
  - 键和值的位置都可以是null,但是键位置只能是一个null(后面这句的意思是,key唯一,即使key是null,也是唯一的,如果我们再来一个{key:null,value:1}就会覆盖掉原本的值为null的key)
  - 键位置是唯一的,底层的数据结构控制键的
  - jdk1.8之前:链表+数组  jdk1.8之后:链表+数组+红黑树
  - 阈值大于8并且数组长度大于64,链表才会转为红黑树,变成红黑树的目的是为了高效的查询
  
  # hashMap的存储过程
  - jdk1.8之前,当创建一个hashmap对象时,会在构造方法中创建一个长度是16的Entry[] table来存储键值对数据
  - jdk1.8之后,不是在hashmap的构造方法底层创建数组了,而是在第一次调用put方法时创建的数组Node[] table来存储键值对数据

  # hashmap成员变量 Default_initial_capacity默认初始容量为什么必须是2的n次幂
    源码:  static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 1 << 4相当于1*2的四次方
  - hashmap的初始容量,为什么必须是2的n次幂(即使我们在初始化一个hashmap时手动指定给大小为17,我发现在底层的代码实现中也会将数组大小初始化为32)
    因为我们将数据存入hashmap的流程需要先对key进行hashcode(),然后在通过算法确定该key应该存储在entry数组的哪一个位置,这个算法本质上就是取模,但是取模的效率比较低,所以源码中
  做了优化,改用hash&(length-1),也正是因为这个算法要求我们的容量必须是2的n次幂,为什么,就是因为length=2的n次幂,所以length-1的结果是全1,而全1则按位与的结果完全取决于hashcode,
  这样可以最大程度的降低hash冲突的概率;(按位与是相同位置都是1,则结果为1,否则结果为0)
    具体演示:
    假如我们现在两个key的计算hashcode分别是8和7,而我们的容量是16,length-1=15那现在要进行按位与运算了
    001000             000111
    001111             001111
    001000 = 8         000111 = 7  
    假如我们现在两个key的计算hashcode分别是8和7,而我们的容量是17,length-1=16那现在要进行按位与运算了
    001000             000111
    010000             010000
    000000 = 0         000000 = 0  
    虽然这个例子很僵硬,但是结论还是能多少看出一点
    按位与里一旦出现0,无论另一个数是0还是1,结果已经是0了,而1则是五五开的情况,hashcode本身没那么容易相同,所以根据hash&(length-1),我们要尽量让length-1不要过多的影响hash的结果,
  所以全1是最好的情况,可以完全把结果交给hash运算的结果,也就可以最大程度的避免hash冲突,让key尽可能均匀的分布在entry数组中;

  # hashMap中最重要的方法 put(),实现步骤大概如下
  - 先通过hash值计算出key映射到数组的哪个位置
  - 如果该位置没有出现冲突,则直接插入
  - 如果出现碰撞了,需要处理冲突
    - 如果使用红黑树处理,则调用红黑树的方法插入数据
    - 如果是链表,则插入,并且需要判断链的长度是否达到阈值,有无必要转换为红黑树
  - 如果该位置存在重复键,则将value替换为新值
  - 如果数组size大于临界值,进行扩容

  # hashmap集合扩容机制和原理
  触发扩容的情况: 当hashmap底层数组大小超过临界值或当一个数组上挂载的链表长度超过8但是entry数组的长度小于64时,也会触发扩容
  
  hashmap进行扩容会伴随一次hash重分配,并且会遍历hash表中所有元素,这非常耗时,所以在写代码时要尽量避免扩容resize
  在jdk8以后,hashmap在扩容时的rehash方式非常巧妙,因为每次扩容都是翻倍,与原来计算的(size-1)&hash的结果相比,只是多了一个bit位,所以节点要么就在原来的位置,要么就被分配到"原位置+旧容量"的位置;
  假设原数组长度为16,n-1=15; 即15&hash                                                           扩容了
              0000 0000 0000 0000 0000 0000 0000 1111             0000 0000 0000 0000 0000 0000 0001 1111
  hashKey1    1111 1111 1111 1111 0000 1111 0000 0101             1111 1111 1111 1111 0000 1111 0000 0101                
  hashKey2    1111 1111 1111 1111 0000 1111 0001 0101             1111 1111 1111 1111 0000 1111 0001 0101
  --------------------------------------------------------------------------------------------------------------
  key1Result  0000 0000 0000 0000 0000 0000 0000 0101             0000 0000 0000 0000 0000 0000 0000 0101
  key2Result  0000 0000 0000 0000 0000 0000 0000 0101             0000 0000 0000 0000 0000 0000 0001 0101
  
  我们扩容之前key1和key2的结果都是0101即对应数组的索引5,而扩容后,key1仍0101,索引为5,而key2虽然变为10101,但转化为索引是5+16=21也就是原位置5+旧容量16 = 新索引21;
  所以在jdk8以后,hashmap扩容时既会计算hash值,只也会关注对应索引上的key的hashcode的新增比特位对应的是0还是1,若是1,则他在新数组的索引就是原索引+旧容量,若是0,则他在新数组的索引还是原索引,
这个取决于结构,即如果是链表结构,那么整条链都不会再次去计算hash了,只会根据我们前面说的关注自己hashcode新增比特位,但如果不是链表结构,也不是树结构,仅仅是一个一个key,那就需要用新数组的长度-1和
自己的hashcode进行一次hash来确定位置了,这个是看源码得到的结论,可靠;
  
  源码中hashmap的扩容流程:
  1)首先是扩容,创建一个是现在数组二倍大小的数组,同时把临界值也调整为原来的二倍,
  2)然后开始遍历旧的hashmap,每拿到一个元素,①先判断是否为null,若不为null要判断是否是链表结构,是否next指针还指向了下一个元素,若未成链,通过hash*(新数组长度-1)的方式计算出其在新数组的索引,将其存入
  新数组,但如果该元素的next还指向其他元素,成链了,那么要开始沿链注意进行判断,判断就是当前这个元素的高一位是0还是1,如果是0,那么它在新数组的索引还是现在的索引,若是1,那他在新数组的索引便是原索引+原数组,
  这一块是jdk8以后优化的一点,就是我们上面讲的内容,很关键;
  ②若非链表还有可能是树结点,这个也需要判断,若是树节点会将红黑树进行拆分
  
  # 遍历hashMap方式
  [代码](/src/main/java/collections/ToHashMap.java)
  