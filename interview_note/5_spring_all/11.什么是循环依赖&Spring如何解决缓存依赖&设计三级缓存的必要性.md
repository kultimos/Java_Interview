# 什么是循环依赖,如何解决循环依赖的问题
  
  ## 循环依赖
  - 通过代码看比较直观:
  - ` @Service
    public class A {
        @Autowired
        private B b;
    }`
  -  `@Service
    public class B {
        @Autowired
        private A a;
    }
  `
  - A在bean的初始化步骤中的属性赋值这一步发现引用了B,所以要先去完成B的bean的初始化,而B在进行初始化时到了属性赋值这一步又发现需要先完成A的bean
  的初始化,二者就发生了循环依赖

  ## spring中是通过三级缓存解决循环依赖
  - 首先理解三级缓存中这三级缓存都是什么
    - 一级缓存: 单例池,用于保存实例化、属性赋值(注入)、初始化三步都完成的bean实例
    - 二级缓存: 存储已经实例化但还未完成依赖注入和初始化的bean对象
    - 三级缓存: 存储beanFactory对象,这个缓存主要是为了处理Bean的创建过程中的延迟依赖问题即循环依赖问题;具体点说,三级缓存中存储的是可以创建
    Bean的ObjectFactory或ObjectProvider实例;

  - 那么现在还是上面那段代码,当A完成实例化后就会将A的对象工厂放入到三级缓存中,表示A已经开始实例化了,虽然这个对象还不完整,但要先曝光出来;
  - A实例化完成后开始进行属性赋值,发现依赖B,而B的bean对象此时还未被创建出来,所以会先去实例化B;
  - B也是进行实例化,并将B的对象工厂存放到三级缓存中;然后B开始进行属性赋值,发现依赖A,会开始以此从一级到三级缓存中查询A,最终从三级缓存中通过对象
  工厂拿到A,并将三级缓存中的A的对象工厂删除,并把这个a的bean对象存入二级缓存中;而B在完成属性注入进而初始化完成后,会存入到一级缓存中;
  - 在完成B的初始化后,A自然可以通过一级缓存中的B完成属性赋值,至此A的初始化也完成,将二级缓存中的A删除,并将A放入一级缓存;
  - 最后,一级缓存中存放着实例化和初始化都完成的A和B的bean实例


  ## 三级缓存的必要性
  - 这里的三级缓存指的并非是第三层缓存,而是为什么spring通过设置三层缓存来解决缓存问题;
  - 代码是这样:
  - ` @Service
    public class A {
      @Autowired
      private B b;
      @Autowired
      private C c;
    }`
  - ` @Service
    public class B {
      @Autowired
      private A a;
    }`
  - ` @Service
    public class C {
      @Autowired
      private A a;
    }`
  - 如果是这样的引用关系,如果只有两层,即只有一级缓存和三级缓存,那么A会在三级缓存中存入一个工厂对象,但是在进行属性注入时,B和C都会去通过这个工厂
  对象获取到bean对象,那么两次工厂方法返回的对象是一致的吗?显然不是,这就是二级缓存的必要性;