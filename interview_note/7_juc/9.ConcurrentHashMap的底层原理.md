# ConcurrentHashMap的底层原理(面试版)
  - 整体架构: 数组+链表+红黑树 默认数组长度16,核心仍然是hashmap
  - 基本功能: 本质上还是一个hashmap,但是提供了并发安全的实现,通过对节点进行加锁保证了更新时的并发安全性;
  - 性能优化
    - 锁粒度的优化: jdk1.8中锁的粒度是数组中的一个节点,而在更早的版本中锁定的是segment,segment锁的范围要更大,所以性能上就不如锁单一节点
    - 引入红黑树: 引入红黑树,降低了对于hash冲突较多的数据情况的数据查询的时间复杂度
    - 扩容时,多线程并发扩容,多个线程对原始数组进行分片,分片之后,每个线程去负责一个分片的数据迁移,从而从整体提升了扩容过程中数据迁移的效率;
    - 在多线程并发场景且保证原子性的前提下,元素个数的累加性能是非常低的,所以ConcurrentHashMap在这做了两点优化
      - 当线程竞争不激烈时,采用cas的方式实现元素个数的原子递增
      - 当线程竞争激烈时,使用一个数组来维护元素个数,如果要增加总的元素个数时,在数组中随机抽取一个,再通过CAS算法实现原子递增;
        这里的核心思想是:引入了数组来实现对并发更新的负载,因为多线程场景下,多个线程对一个数据操作极容易出现线程安全问题,但我们现在是修改数组中一个随机索引的数值,
      这样的好处就是即使有10个线程同一时刻来访问,他们更新的也是数组里10个不同索引的值,并发安全问题出现的概率就被大大降低了;