# 谈谈你对AQS的理解
  AQS是Abstract Queued Synchronizer————多线程同步器;它是JUC包下多个组件的底层实现都用到了AQS;
  AQS有两个重要属性:state和同步队列;
  - state
    state是一个volatile修饰的成员变量,用来表示同步状态,0表示当前没有任何线程竞争到锁资源,而大于等于1则表示已经有线程正在持有锁资源
  - 同步队列(当我们将获取锁失败的线程企图存入该同步队列时,会将线程封装成一个Node节点,而这个Node节点中又有很多属性来帮我完善锁的实现;)
    - SHARED: 表示线程以共享的模式等待锁
    - EXCLUSIVE: 表示线程以独占的方式等待锁
    - prev: 前驱指针
    - next: 后继指针
    - head: 同步队列的头指针
    - tail: 同步队列的尾指针
    - thread: 线程尝试获取锁时,就会被封装为一个node对象来参与锁的竞争和等待,这个属性thread就用来接收线程对象信息
    - waitStatus: 表示当前节点在队列中的状态,具体的状态由下面几种
      - CANCELLED: 表示线程获取锁的请求已经取消
      - SIGNAL: 表示线程已经准备就绪,就等锁被释放
      - CONDITION: 表示线程进入了条件等待状态(condition.await()),并在条件满足时被唤醒;
      - PROPAGATE:目前我的理解感觉是:这个属性针对的是共享锁的问题处理,如果是一个共享模式的线程获取了锁,那么其实跟他属性类似的线程也就有访问共享变量的能力,
                  通过该属性就可以唤醒其他PROPAGATE线程来实现共享访问,提高效率
    
  ReentrantLock底层应用AQS的基本方法
  public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    selfInterrupt();
  }
  这个代码片段就是整个ReentrantLock底层AQS多线程获取锁的最核心的代码,一共三个方法,分别对应着不同的作用
  tryAcquire方法表示尝试加锁,每个进来的线程都会去尝试获取锁,这部分主要依赖于AQS的队列属性state,通过判断state的状态值0空闲,1已被持有来对线程能否持有锁进行逻辑判断;
  addWaiter方法用于处理未获取锁的线程进入阻塞队列,该阻塞队列的实现也是依赖于AQS的属性head和tail,我们会在该阻塞队列中设置一个虚拟节点以便后续的处理;
  acquireQueued方法用于将入队的线程置于阻塞状态,需要注意这些入队的线程会在acquireQueued方法中再次去尝试获取一次锁,一旦这次获取失败,就会进入在队列中进入阻塞状态,这里的阻塞是通过
LockSupport的park()实现的;

  后续当持有锁的线程执行任务结束,释放锁后,底层会去通过AQS的head属性获取head.next(),即拿到阻塞队列中最先入队的线程,LockSupport.unPark(thread)会按照入队顺序去将最先入队的线程唤醒;
  这里可以讲的点就比较多:
- 首先是公平锁和非公平锁底层如何实现？
  easy,其实公平锁只比非公平锁多了一步,就是公平锁会先去阻塞队列里查看一下,有没有还在阻塞的线程,若有,队列中阻塞线程是优先的,且是按照入队顺序去获取锁;
  而非公平锁则是不会考虑阻塞队列的问题,直接去尝试获取锁;

- 关于非公平锁
  即使是非公平锁也依然会按照阻塞队列的入队顺序去唤醒线程,那他之所以是非公平锁,是因为可能存在锁被未入队的新线程抢占的情况,因为非公平锁时,新线程不会考虑阻塞队列;
  但如果不考虑新线程涌入的情况,那么即使是非公平锁,也会按照阻塞队列的入队顺序唤醒线程;
  非公平锁不是完全不公平的,对于已经进入阻塞队列的线程,其实非公平锁也是公平的,会按照他们入队的顺序逐一唤醒;